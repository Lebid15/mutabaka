name: Deploy Mutabaka

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    env:
      REGISTRY: ghcr.io/lebid15
      IMAGE_NAME: mutabaka

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # Login to GitHub Container Registry early (so Buildx can pull buildkit image from GHCR if needed)
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      # Login to Docker Hub to avoid 401 Unauthorized / rate-limit when pulling base images (e.g., python:3.12-slim)
      - name: Docker Hub login (optional)
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        shell: bash
        run: |
          if [ -n "${DOCKERHUB_USERNAME}" ] && [ -n "${DOCKERHUB_TOKEN}" ]; then
            echo "Logging into Docker Hub to avoid pull rate limits..."
            echo "${DOCKERHUB_TOKEN}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin
          else
            echo "Skipping Docker Hub login (credentials not provided)."
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver: docker

      - name: Docker info
        run: docker info

      - name: Buildx version
        run: docker buildx version

      - name: Build & push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          build-args: |
            BASE_IMAGE=public.ecr.aws/docker/library/python:3.12-slim
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ github.sha }}

      - name: Build & push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          build-args: |
            NEXT_PUBLIC_VAPID_PUBLIC_KEY=${{ secrets.VAPID_PUBLIC_KEY }}
            NEXT_PUBLIC_PUSHER_KEY=${{ secrets.PUSHER_KEY }}
            NEXT_PUBLIC_PUSHER_CLUSTER=${{ secrets.PUSHER_CLUSTER }}
            NEXT_PUBLIC_SW_VERSION=${{ github.sha }}
            BASE_NODE_IMAGE=public.ecr.aws/docker/library/node:20-alpine
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}

      - name: Configure SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          PORT_FLAG=""
          if [ -n "${SSH_PORT}" ] && [[ "${SSH_PORT}" =~ ^[0-9]+$ ]]; then PORT_FLAG="-p ${SSH_PORT}"; fi
          ssh-keyscan ${PORT_FLAG} ${HOST} >> ~/.ssh/known_hosts
        env:
          HOST: ${{ secrets.HOST }}
          SSH_PORT: ${{ secrets.SSH_PORT }}

      - name: Validate required inputs (diagnostic)
        shell: bash
        run: |
          set -e -o pipefail
          set -x
          # Print boolean presence flags and lengths (secrets are masked by GitHub to ***)
          echo "HAS_HOST=$([[ -n "${HOST:-}" ]] && echo 1 || echo 0)"
          echo "HAS_USER=$([[ -n "${USER:-}" ]] && echo 1 || echo 0)"
          echo "HAS_SERVER_PATH=$([[ -n "${SERVER_PATH:-}" ]] && echo 1 || echo 0)"
          echo "HAS_REGISTRY_USERNAME=$([[ -n "${REGISTRY_USERNAME:-}" ]] && echo 1 || echo 0)"
          echo "HAS_REGISTRY_TOKEN=$([[ -n "${REGISTRY_TOKEN:-}" ]] && echo 1 || echo 0)"
          echo "HAS_SSH_PORT=$([[ -n "${SSH_PORT:-}" ]] && echo 1 || echo 0)"  # optional
          printf 'LEN_HOST=%s\n' "${#HOST}" || true
          printf 'LEN_USER=%s\n' "${#USER}" || true
          printf 'LEN_SERVER_PATH=%s\n' "${#SERVER_PATH}" || true
          # Dump a sample of env for context (values of secrets are masked automatically)
          env | sort | sed -n '1,40p'

          FAIL=0
          if [ -z "${HOST:-}" ]; then echo "HOST missing"; FAIL=1; fi
          if [ -z "${USER:-}" ]; then echo "USER missing"; FAIL=1; fi
          if [ -z "${SERVER_PATH:-}" ]; then echo "SERVER_PATH missing"; FAIL=1; fi
          # These are required for docker login later
          if [ -z "${REGISTRY_USERNAME:-}" ]; then echo "REGISTRY_USERNAME missing"; FAIL=1; fi
          if [ -z "${REGISTRY_TOKEN:-}" ]; then echo "REGISTRY_TOKEN missing"; FAIL=1; fi
          if [ "$FAIL" -ne 0 ]; then exit 1; fi
        env:
          HOST: ${{ secrets.HOST }}
          USER: ${{ secrets.USER }}
          SERVER_PATH: ${{ secrets.SERVER_PATH }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
          SSH_PORT: ${{ secrets.SSH_PORT }}

      - name: Upload deploy artifacts (compose, nginx, env example)
        run: |
          [ -z "${HOST}" ] && { echo "HOST missing"; exit 1; }
          [ -z "${USER}" ] && { echo "USER missing"; exit 1; }
          [ -z "${SERVER_PATH}" ] && { echo "SERVER_PATH missing"; exit 1; }
          SSH_CMD="ssh"
          if [ -n "${SSH_PORT}" ] && [[ "${SSH_PORT}" =~ ^[0-9]+$ ]]; then SSH_CMD="ssh -p ${SSH_PORT}"; fi
          rsync -avz -e "$SSH_CMD" ./deploy/ ${USER}@${HOST}:${SERVER_PATH}/
        env:
          HOST: ${{ secrets.HOST }}
          USER: ${{ secrets.USER }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          SERVER_PATH: ${{ secrets.SERVER_PATH }}

      - name: Deploy on server
        run: |
          PORT_FLAG=""
          if [ -n "${SSH_PORT}" ] && [[ "${SSH_PORT}" =~ ^[0-9]+$ ]]; then PORT_FLAG="-p ${SSH_PORT}"; fi
          ssh ${PORT_FLAG} ${USER}@${HOST} << EOF
          set -e
          mkdir -p "${SERVER_PATH}"
          cd "${SERVER_PATH}"
          mkdir -p media static data
          # Preserve existing .env; create from example if missing
          if [ ! -f .env ] && [ -f .env.example ]; then cp .env.example .env; fi
          # Ensure REGISTRY and IMAGE_NAME are set correctly
          if grep -q '^REGISTRY=' .env 2>/dev/null; then
            sed -i 's|^REGISTRY=.*|REGISTRY=${REGISTRY}|' .env
          else
            echo "REGISTRY=${REGISTRY}" >> .env
          fi
          if grep -q '^IMAGE_NAME=' .env 2>/dev/null; then
            sed -i 's|^IMAGE_NAME=.*|IMAGE_NAME=${IMAGE_NAME}|' .env
          else
            echo "IMAGE_NAME=${IMAGE_NAME}" >> .env
          fi
          # Pin image tags to this commit for deterministic pulls
          if grep -q '^BACKEND_TAG=' .env 2>/dev/null; then
            sed -i 's|^BACKEND_TAG=.*|BACKEND_TAG=${GITHUB_SHA}|' .env
          else
            echo "BACKEND_TAG=${GITHUB_SHA}" >> .env
          fi
          if grep -q '^FRONTEND_TAG=' .env 2>/dev/null; then
            sed -i 's|^FRONTEND_TAG=.*|FRONTEND_TAG=${GITHUB_SHA}|' .env
          else
            echo "FRONTEND_TAG=${GITHUB_SHA}" >> .env
          fi
          # Login to registry in case it is private
          echo ${REGISTRY_TOKEN} | docker login ghcr.io -u ${REGISTRY_USERNAME} --password-stdin
          # Optional Docker Hub login to avoid 401/ rate limits for library images
          if [ -n "${DOCKERHUB_USERNAME}" ] && [ -n "${DOCKERHUB_TOKEN}" ]; then
            echo "Attempting Docker Hub login..."
            echo "${DOCKERHUB_TOKEN}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin || echo "Docker Hub login failed (continuing)"
          else
            echo "No Docker Hub creds provided; will fall back to public ECR mirror for library images if pull fails."
          fi
          # Pull with retries + fallback substitution to public ECR mirror if unauthorized occurs for nginx/redis/postgres
          set +e
          docker compose pull 2>pull.err
          PULL_RC=$?
          if grep -qi 'unauthorized' pull.err || [ $PULL_RC -ne 0 ]; then
            echo "Detected unauthorized/rate-limit while pulling. Applying mirror substitutions..."
            # Create a temp modified compose file mapping library images to public.ecr.aws mirrors
            cp docker-compose.yml docker-compose.mirror.yml || true
            sed -i 's|nginx:1.27-alpine|public.ecr.aws/docker/library/nginx:1.27-alpine|g; s|redis:7-alpine|public.ecr.aws/docker/library/redis:7-alpine|g; s|postgres:16-alpine|public.ecr.aws/docker/library/postgres:16-alpine|g' docker-compose.mirror.yml || true
            echo "Retrying pull with mirrors..."
            docker compose -f docker-compose.mirror.yml pull || true
            echo "Bringing up services with mirror compose (will still use ghcr images for backend/frontend)."
            docker compose -f docker-compose.mirror.yml up -d || true
          else
            echo "Initial pull succeeded. Proceeding to up -d."
            docker compose up -d
          fi
          set -e
          docker image prune -f || true
          EOF
        env:
          HOST: ${{ secrets.HOST }}
          USER: ${{ secrets.USER }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          SERVER_PATH: ${{ secrets.SERVER_PATH }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          GITHUB_SHA: ${{ github.sha }}
          REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
